<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BitRegataStart</title>
  <style>
    :root {
      --bg: #edf3f8;
      --panel: #ffffff;
      --ink: #10212f;
      --muted: #5f6f7d;
      --line: #d7e0e8;
      --accent: #005f73;
      --accent2: #0a9396;
      --warn: #b45309;
      --danger: #9a3412;
      --shadow: 0 10px 24px rgba(16, 33, 47, 0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(circle at 10% 10%, rgba(10,147,150,.10), transparent 34%),
        radial-gradient(circle at 90% 12%, rgba(0,95,115,.10), transparent 42%),
        var(--bg);
    }
    .app {
      min-height: 100vh;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 10px;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: var(--shadow);
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    .panel-header {
      padding: 14px 16px 10px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(10,147,150,.04), rgba(255,255,255,0));
    }
    .panel-header h1 { margin: 0; font-size: 1.05rem; }
    .panel-header p { margin: 5px 0 0; color: var(--muted); font-size: .84rem; }
    .panel-body {
      padding: 12px;
      display: grid;
      gap: 10px;
      align-content: start;
      overflow: auto;
    }
    .section {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      padding: 10px;
    }
    .section h2 { margin: 0 0 8px; font-size: .95rem; }
    .grid-2, .grid-3 {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    label {
      display: grid;
      gap: 4px;
      font-size: .78rem;
      color: var(--muted);
      min-width: 0;
    }
    label.inline {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--ink);
      font-size: .8rem;
    }
    input, select, button { font: inherit; }
    input[type="number"], select {
      width: 100%;
      min-width: 0;
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px 9px;
      background: #fff;
      color: var(--ink);
    }
    input[type="checkbox"] { accent-color: var(--accent); }
    input[type="number"]:focus-visible, select:focus-visible, button:focus-visible {
      outline: 2px solid rgba(10,147,150,.35);
      outline-offset: 1px;
      border-color: var(--accent2);
    }
    .actions {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }
    button {
      border: 1px solid var(--line);
      border-radius: 9px;
      background: #fff;
      color: var(--ink);
      padding: 10px 12px;
      cursor: pointer;
      transition: background-color 120ms ease, border-color 120ms ease, transform 80ms ease;
    }
    button:hover { border-color: #b9c7d3; background: #fbfdff; }
    button:active { transform: translateY(1px); }
    button.primary {
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      color: #fff;
      border-color: transparent;
    }
    .hint { color: var(--muted); font-size: .75rem; }
    .status {
      border: 1px solid var(--line);
      background: #f7fbfd;
      border-radius: 8px;
      padding: 8px 10px;
      font-size: .77rem;
    }
    .summary-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }
    .metric {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px;
      background: #fbfdff;
    }
    .metric .k { display: block; color: var(--muted); font-size: .72rem; margin-bottom: 4px; }
    .metric .v { font-size: .9rem; font-weight: 600; line-height: 1.25; word-break: break-word; }
    .diagram-wrap {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: linear-gradient(180deg, #fafdff, #f6fbff);
      overflow: hidden;
    }
    #diagram {
      width: 100%;
      height: auto;
      display: block;
      aspect-ratio: 16 / 10;
    }
    .legend {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }
    .legend-item {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px;
      background: #fff;
      font-size: .76rem;
    }
    .diagram-stats {
      margin-top: 8px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .diagram-stats-col {
      display: grid;
      gap: 6px;
      align-content: start;
    }
    .diagram-stats-line {
      color: #334155;
      font-size: .9rem;
      line-height: 1.25;
    }
    .diagram-stats-line strong {
      color: #10212f;
      font-weight: 700;
    }
    .swatch {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: middle;
    }
    .sw-cb { background: #7c2d12; }
    .sw-pin { background: #1d4ed8; }
    .sw-m1 { background: #0f766e; }
    .table-wrap {
      border: 1px solid var(--line);
      border-radius: 8px;
      overflow: auto;
      max-height: 320px;
    }
    table { width: 100%; border-collapse: collapse; font-size: .74rem; }
    th, td {
      border-bottom: 1px solid var(--line);
      padding: 6px 4px;
      text-align: left;
      vertical-align: top;
    }
    th { background: #f8fbfd; position: sticky; top: 0; z-index: 1; }
    .footnote { color: var(--muted); font-size: .72rem; }
    @media (min-width: 981px) {
      .app { grid-template-columns: minmax(380px, 520px) 1fr; padding: 12px; }
      .grid-2 { grid-template-columns: 1fr 1fr; }
      .grid-3 { grid-template-columns: 1fr 1fr 1fr; }
      .actions { grid-template-columns: 1fr 1fr; }
      .summary-grid { grid-template-columns: 1fr 1fr; }
      .legend { grid-template-columns: 1fr 1fr; }
      .diagram-stats { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <div class="app">
    <section class="panel">
      <div class="panel-header">
        <h1>BitRegataStart</h1>
        <p>Start-line only: RC (Race Committee), Pin End, and Mark 1. No map, only a bearing diagram.</p>
      </div>
      <div class="panel-body">
        <div class="section">
          <h2>Start Line Setup</h2>
          <div class="grid-2">
            <label>TWD (°, from)<input id="twd" type="number" min="0" max="359" step="1"></label>
            <label>TWS (kn)<input id="tws" type="number" min="0" step="0.1"></label>
            <label>Current Set (to, °)<input id="currentSet" type="number" min="0" max="359" step="1"></label>
            <label>Current Drift (kn)<input id="currentDrift" type="number" min="0" step="0.1"></label>
            <label>Class<select id="boatClass"></select></label>
            <label>Boats (N)<input id="participants" type="number" min="1" step="1"></label>
            <label>Fleet Skill Level
              <select id="fleetLevel">
                <option value="Beginner">Beginner</option>
                <option value="Intermediate">Intermediate</option>
                <option value="Expert">Expert</option>
              </select>
            </label>
            <label>Mark 1 Distance Mode
              <select id="d1Mode">
                <option value="distance">Distance Input (NM)</option>
                <option value="time">Upwind Time Input (min)</option>
              </select>
            </label>
            <label id="d1NmWrap">Mark 1 Distance (NM)<input id="d1Nm" type="number" min="0.01" step="0.01"></label>
            <label id="d1TimeWrap">Target Upwind Time (min)<input id="targetTimeUpwindMin" type="number" min="1" step="0.1"></label>
          </div>
          <div class="grid-2" style="margin-top:8px;">
            <label class="inline"><input id="useManualLineLength" type="checkbox"> Manual Line Length Override</label>
            <label class="inline"><input id="rule3Enabled" type="checkbox"> Rule 3 Correction (Mark 1)</label>
            <label>Line Length (m)<input id="lineLengthOverrideM" type="number" min="1" step="1"></label>
            <label>Line Length (NM)<input id="lineLengthOverrideNm" type="number" min="0.001" step="0.001"></label>
          </div>
        </div>

        <div class="section">
          <h2>Advanced Line Settings</h2>
          <div class="grid-2">
            <label class="inline"><input id="waveEnabled" type="checkbox"> Enable Wave Correction</label>
            <div></div>
            <label>Base Padding (m)<input id="basePaddingM" type="number" min="0" step="1"></label>
            <label>Current Factor (k_current)<input id="kCurrent" type="number" min="0" step="0.1"></label>
            <label>Wave Factor (k_wave)<input id="kWave" type="number" min="0" step="0.1"></label>
            <label>Min Line Length Clamp (m)<input id="lineClampMinM" type="number" min="1" step="1"></label>
            <label>Max Line Length Clamp (m)<input id="lineClampMaxM" type="number" min="1" step="1"></label>
            <label>Max Total Line Delta Clamp (Current + Waves, °)<input id="deltaLineClampDeg" type="number" min="0" step="0.1"></label>
            <label>Mark 1 Time Multiplier<input id="mark1TimeMultiplier" type="number" min="0.1" step="0.05"></label>
            <label>Wave Height (m)<input id="waveHeightM" type="number" min="0" step="0.1"></label>
            <label>Wave Direction (from, °)<input id="waveDirectionFromDeg" type="number" min="0" max="359" step="1"></label>
          </div>
          <div class="hint" style="margin-top:8px;">The start line is computed from RC (Race Committee) to Pin End (bearing RC→Pin). Total line correction = current + waves. Current Set is a TO direction; Wave Direction is a FROM direction.</div>
        </div>

        <div class="section">
          <h2>Actions</h2>
          <div class="actions">
            <button id="recomputeAll" class="primary">Recompute</button>
            <button id="resetDefaults">Reset Defaults</button>
          </div>
          <div class="status" id="appStatus" aria-live="polite" style="margin-top:8px;">Change inputs to update the start line, Mark 1, and bearings.</div>
        </div>

        <div class="footnote">
          1 NM = 1852 m. All bearings are true (0-359). TWD is wind direction “from”.
        </div>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header">
        <h1>Start Line Diagram</h1>
        <p>Clean briefing schematic with wind, current, and start line only.</p>
      </div>
      <div class="panel-body">
        <div class="section">
          <div class="diagram-wrap">
            <svg id="diagram" viewBox="0 0 1000 620" role="img" aria-label="Start line schematic"></svg>
          </div>
          <div id="diagramStats" class="diagram-stats" aria-live="polite"></div>
          <div class="legend" style="margin-top:8px;">
            <div class="legend-item"><span class="swatch sw-cb"></span><b>RC</b> Race Committee (line end)</div>
            <div class="legend-item"><span class="swatch sw-pin"></span><b>Pin</b> Pin End (line end)</div>
            <div class="legend-item"><b>Black Arrow</b> = Wind flow direction (arrow points where wind goes)</div>
            <div class="legend-item"><b>Blue Arrow</b> = Current set direction (where current flows)</div>
          </div>
        </div>

        <div class="section">
          <h2>Line / Mark 1 Output</h2>
          <div class="summary-grid" id="summaryGrid"></div>
          <div class="hint" id="rule3Summary" style="margin-top:8px;"></div>
        </div>

        <div class="section">
          <h2>Bearings and Distances</h2>
          <div class="table-wrap">
            <table id="pointsTable">
              <thead>
                <tr>
                  <th>Point</th>
                  <th>Bearing from Center (°)</th>
                  <th>Bearing from RC raw (°)</th>
                  <th>Bearing from RC corrected (°)</th>
                  <th>Bearing from Pin (°)</th>
                  <th>Distance from Center (NM)</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    const NM_TO_M = 1852;
    const M_TO_NM = 1 / NM_TO_M;
    const EARTH_R_M = 6371000;
    const TWS_REF = 6;
    const BOAT_CLASSES = ["Optimist", "ILCA", "420", "470", "J70"];
    const LEVEL_MULTIPLIER = { Beginner: 1.25, Intermediate: 1.10, Expert: 1.00 };

    const DEFAULT_STATE = {
      committeeBoat: { lat: 43.547600, lon: 10.303200 },
      inputs: {
        twd: 315,
        tws: 12,
        currentSet: 280,
        currentDrift: 0.8,
        boatClass: "ILCA",
        participants: 40,
        fleetLevel: "Intermediate",
        d1Mode: "distance",
        d1Nm: 0.8,
        targetTimeUpwindMin: 18,
        useManualLineLength: false,
        lineLengthOverrideM: 160,
        lineLengthOverrideNm: 160 * M_TO_NM,
        rule3Enabled: true
      },
      advanced: {
        baseSpacingPerBoatM: { Optimist: 2.5, ILCA: 3.5, "420": 4.2, "470": 4.7, J70: 6.5 },
        basePaddingM: 20,
        lineClampMinM: 60,
        lineClampMaxM: 600,
        kCurrent: 8,
        kWave: 2.5,
        deltaLineClampDeg: 8,
        mark1TimeMultiplier: 1,
        waveEnabled: true,
        waveHeightM: 0,
        waveDirectionFromDeg: 0
      },
      speedModels: {
        Optimist: { upwind: { base: 2.2, slope: 0.08, min: 2.0, max: 4.0 } },
        ILCA: { upwind: { base: 3.6, slope: 0.10, min: 3.0, max: 5.5 } },
        "420": { upwind: { base: 3.8, slope: 0.11, min: 3.2, max: 6.0 } },
        "470": { upwind: { base: 4.0, slope: 0.12, min: 3.5, max: 6.2 } },
        J70: { upwind: { base: 4.8, slope: 0.12, min: 4.0, max: 7.0 } }
      }
    };

    const appState = JSON.parse(JSON.stringify(DEFAULT_STATE));
    const derivedState = {
      line: null,
      mark1: null,
      d1: null,
      rule3: null,
      speeds: null,
      pointsRows: []
    };
    const ui = {};

    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
    const mod360 = (v) => ((v % 360) + 360) % 360;
    const degToRad = (d) => d * Math.PI / 180;
    const radToDeg = (r) => r * 180 / Math.PI;
    const signedAngleDiffDeg = (toDeg, fromDeg) => ((toDeg - fromDeg + 540) % 360) - 180;

    function point(lat, lon) { return { lat: Number(lat), lon: Number(lon) }; }

    function destinationMeters(origin, meters, bearingDeg) {
      const brng = degToRad(mod360(bearingDeg));
      const d = meters / EARTH_R_M;
      const lat1 = degToRad(origin.lat);
      const lon1 = degToRad(origin.lon);
      const sinLat1 = Math.sin(lat1), cosLat1 = Math.cos(lat1);
      const sinD = Math.sin(d), cosD = Math.cos(d);
      const sinLat2 = sinLat1 * cosD + cosLat1 * sinD * Math.cos(brng);
      const lat2 = Math.asin(sinLat2);
      const y = Math.sin(brng) * sinD * cosLat1;
      const x = cosD - sinLat1 * sinLat2;
      const lon2 = lon1 + Math.atan2(y, x);
      return { lat: radToDeg(lat2), lon: radToDeg(lon2) };
    }

    function distanceMeters(a, b) {
      const lat1 = degToRad(a.lat), lat2 = degToRad(b.lat);
      const dLat = lat2 - lat1;
      const dLon = degToRad(b.lon - a.lon);
      const s1 = Math.sin(dLat / 2);
      const s2 = Math.sin(dLon / 2);
      const h = s1 * s1 + Math.cos(lat1) * Math.cos(lat2) * s2 * s2;
      return 2 * EARTH_R_M * Math.asin(Math.min(1, Math.sqrt(h)));
    }
    function distanceNm(a, b) { return distanceMeters(a, b) * M_TO_NM; }

    function initialBearingTrue(a, b) {
      const lat1 = degToRad(a.lat), lat2 = degToRad(b.lat), dLon = degToRad(b.lon - a.lon);
      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
      return mod360(radToDeg(Math.atan2(y, x)));
    }

    function localXYMeters(origin, p) {
      const lat0 = degToRad(origin.lat);
      return {
        x: degToRad(p.lon - origin.lon) * EARTH_R_M * Math.cos(lat0),
        y: degToRad(p.lat - origin.lat) * EARTH_R_M
      };
    }
    const cross2D = (a, b) => a.x * b.y - a.y * b.x;

    function computeUpwindSpeedKn(state) {
      const cls = state.inputs.boatClass;
      const tws = Number(state.inputs.tws || 0);
      const model = state.speedModels[cls].upwind;
      return clamp(model.base + model.slope * (tws - TWS_REF), model.min, model.max);
    }

    function computeAutoLineLengthM(state) {
      const i = state.inputs, a = state.advanced;
      const spacing = Number(a.baseSpacingPerBoatM[i.boatClass] || 0);
      const padding = Number(a.basePaddingM || 0);
      const raw = (Number(i.participants) * spacing + padding) * (LEVEL_MULTIPLIER[i.fleetLevel] || 1);
      return clamp(raw, Number(a.lineClampMinM), Number(a.lineClampMaxM));
    }

    function computeWaveEffects(state, upwindHeadingDeg) {
      const a = state.advanced;
      const waveEnabled = !!a.waveEnabled;
      const tws = Math.max(0, Number(state.inputs.tws || 0));
      const waveHeightM = Math.max(0, Number(a.waveHeightM || 0));
      const waveFromDeg = mod360(Number(a.waveDirectionFromDeg || 0));
      const waveToDeg = mod360(waveFromDeg + 180);

      if (!waveEnabled) {
        return { waveEnabled, waveHeightM, waveFromDeg, waveToDeg, rawWaveDeltaDeg: 0, waveTimeFactor: 1 };
      }

      // Line bearing effect: use the cross component of wave propagation relative to TWD.
      const rawWaveDeltaDeg = Number(a.kWave || 0) * waveHeightM *
        Math.sin(degToRad(signedAngleDiffDeg(waveToDeg, Number(state.inputs.twd)))) / Math.max(1, tws);

      // Time effect: waves from ahead on the upwind leg penalize time more than following seas.
      const headSeaAlignment = (1 + Math.cos(degToRad(signedAngleDiffDeg(waveFromDeg, upwindHeadingDeg)))) / 2; // 0..1
      const waveTimeFactor = clamp(1 + (0.18 * waveHeightM * (0.35 + 0.65 * headSeaAlignment)), 1, 2.5);

      return { waveEnabled, waveHeightM, waveFromDeg, waveToDeg, rawWaveDeltaDeg, waveTimeFactor };
    }

    function computeLine(state) {
      const cb = point(state.committeeBoat.lat, state.committeeBoat.lon);
      const twd = mod360(Number(state.inputs.twd));
      const tws = Math.max(0, Number(state.inputs.tws));
      const setDir = mod360(Number(state.inputs.currentSet));
      const drift = Math.max(0, Number(state.inputs.currentDrift));
      const upwindHeading = mod360(twd + 180);

      const rawCurrentDeltaDeg = Number(state.advanced.kCurrent) * drift * Math.sin(degToRad(signedAngleDiffDeg(setDir, twd))) / Math.max(1, tws);
      const waveFx = computeWaveEffects(state, upwindHeading);
      const rawDelta = rawCurrentDeltaDeg + waveFx.rawWaveDeltaDeg;
      const deltaLineDeg = clamp(rawDelta, -Number(state.advanced.deltaLineClampDeg), Number(state.advanced.deltaLineClampDeg));
      const lineHeading = mod360(twd + 90 + deltaLineDeg);

      const autoLengthM = computeAutoLineLengthM(state);
      const lengthM = state.inputs.useManualLineLength ? Math.max(1, Number(state.inputs.lineLengthOverrideM)) : autoLengthM;
      const pin = destinationMeters(cb, lengthM, lineHeading);
      const center = destinationMeters(cb, lengthM / 2, lineHeading);

      return {
        cb, pin, center,
        headingDeg: lineHeading,
        upwindHeadingDeg: upwindHeading,
        deltaCurrentDeg: rawCurrentDeltaDeg,
        deltaWaveDeg: waveFx.rawWaveDeltaDeg,
        deltaLineDeg,
        waveEnabled: waveFx.waveEnabled,
        waveTimeFactor: waveFx.waveTimeFactor,
        waveHeightM: waveFx.waveHeightM,
        waveDirectionFromDeg: waveFx.waveFromDeg,
        lengthM,
        lengthNm: lengthM * M_TO_NM,
        autoLengthM,
        autoLengthNm: autoLengthM * M_TO_NM
      };
    }

    function getD1MetersFromState(state, upwindSpeedKn) {
      if (state.inputs.d1Mode === "time") {
        const d1Nm = (upwindSpeedKn / 60) * Number(state.inputs.targetTimeUpwindMin || 0);
        return { source: "time", d1Nm, d1M: d1Nm * NM_TO_M };
      }
      const d1Nm = Number(state.inputs.d1Nm || 0);
      return { source: "distance", d1Nm, d1M: d1Nm * NM_TO_M };
    }

    function computeMark1(line, d1) {
      return {
        id: "M1",
          name: "Mark 1",
        ...destinationMeters(line.center, d1.d1M, line.upwindHeadingDeg)
      };
    }

    function computeRule3(line, mark1) {
      const bearingCenter = initialBearingTrue(line.center, mark1);
      const bearingCbRaw = initialBearingTrue(line.cb, mark1);
      const D = Math.max(1, distanceMeters(line.center, mark1));
      const parallaxDeg = radToDeg(Math.atan((line.lengthM / 2) / D));

      const vCenter = localXYMeters(line.cb, line.center);
      const vMark = localXYMeters(line.cb, mark1);
      const cross = cross2D(vCenter, vMark);

      let side = "centerline";
      let sign = 0;
      if (cross > 0) { side = "left"; sign = -1; }
      else if (cross < 0) { side = "right"; sign = +1; }
      const correctionAppliedDeg = sign * parallaxDeg;
      // Diagnostic: adjusts the RC raw bearing back toward the center-line reference.
      const bearingCbCompensated = mod360(bearingCbRaw + correctionAppliedDeg);
      // Operational RC reading requested by user: center-line bearing +/- Rule 3 correction.
      const bearingRcCorrectedFromCenter = mod360(bearingCenter + correctionAppliedDeg);

      return {
        bearingCenter,
        bearingCbRaw,
        bearingCbCompensated,
        bearingRcCorrectedFromCenter,
        parallaxDeg,
        side,
        correctionAppliedDeg,
        deltaCenterVsCbRawDeg: signedAngleDiffDeg(bearingCbRaw, bearingCenter),
        deltaCenterVsCbCorrectedDeg: signedAngleDiffDeg(bearingCbCompensated, bearingCenter)
      };
    }

    function recomputeDerived() {
      const line = computeLine(appState);
      const upwindSpeedKn = computeUpwindSpeedKn(appState);
      const d1 = getD1MetersFromState(appState, upwindSpeedKn);
      const mark1 = computeMark1(line, d1);
      const rule3 = computeRule3(line, mark1);

      derivedState.line = line;
      derivedState.mark1 = mark1;
      derivedState.d1 = d1;
      derivedState.rule3 = rule3;
      derivedState.speeds = { upwindKn: upwindSpeedKn };
      derivedState.pointsRows = [
        {
          name: "RC",
          p: line.cb,
          bearingCenter: initialBearingTrue(line.center, line.cb),
          bearingCb: 0,
          bearingPin: initialBearingTrue(line.pin, line.cb),
          distNm: distanceNm(line.center, line.cb)
        },
        {
          name: "Pin",
          p: line.pin,
          bearingCenter: initialBearingTrue(line.center, line.pin),
          bearingCb: initialBearingTrue(line.cb, line.pin),
          bearingPin: 0,
          distNm: distanceNm(line.center, line.pin)
        },
        {
          name: "M1",
          p: mark1,
          bearingCenter: initialBearingTrue(line.center, mark1),
          bearingCb: initialBearingTrue(line.cb, mark1),
          bearingPin: initialBearingTrue(line.pin, mark1),
          distNm: distanceNm(line.center, mark1)
        }
      ];
    }

    const fmt = (n, d = 2) => (n == null || Number.isNaN(n)) ? "—" : Number(n).toFixed(d);
    const fmtCoord = (n) => (n == null || Number.isNaN(n)) ? "—" : Number(n).toFixed(6);
    const fmtDeg = (n) => (n == null || Number.isNaN(n)) ? "—" : String(Math.round(mod360(n)));

    function setStatus(text) { ui.appStatus.textContent = text; }

    function sanitizeState() {
      const i = appState.inputs;
      const a = appState.advanced;
      appState.committeeBoat.lat = clamp(Number(appState.committeeBoat.lat || 0), -90, 90);
      appState.committeeBoat.lon = clamp(Number(appState.committeeBoat.lon || 0), -180, 180);

      i.twd = mod360(Number(i.twd || 0));
      i.tws = Math.max(0, Number(i.tws || 0));
      i.currentSet = mod360(Number(i.currentSet || 0));
      i.currentDrift = Math.max(0, Number(i.currentDrift || 0));
      i.participants = Math.max(1, Math.round(Number(i.participants || 1)));
      i.d1Nm = Math.max(0.01, Number(i.d1Nm || 0.01));
      i.targetTimeUpwindMin = Math.max(1, Number(i.targetTimeUpwindMin || 1));
      i.lineLengthOverrideM = Math.max(1, Number(i.lineLengthOverrideM || 1));
      i.lineLengthOverrideNm = i.lineLengthOverrideM * M_TO_NM;
      i.rule3Enabled = !!i.rule3Enabled;

      a.basePaddingM = Math.max(0, Number(a.basePaddingM || 0));
      a.kCurrent = Math.max(0, Number(a.kCurrent || 0));
      a.kWave = Math.max(0, Number(a.kWave || 0));
      a.lineClampMinM = Math.max(1, Number(a.lineClampMinM || 1));
      a.lineClampMaxM = Math.max(a.lineClampMinM, Number(a.lineClampMaxM || a.lineClampMinM));
      a.deltaLineClampDeg = Math.max(0, Number(a.deltaLineClampDeg || 0));
      a.mark1TimeMultiplier = Math.max(0.1, Number(a.mark1TimeMultiplier || 1));
      a.waveEnabled = !!a.waveEnabled;
      a.waveHeightM = Math.max(0, Number(a.waveHeightM || 0));
      a.waveDirectionFromDeg = mod360(Number(a.waveDirectionFromDeg || 0));
    }

    function updateConditionalUI() {
      ui.d1NmWrap.style.display = appState.inputs.d1Mode === "distance" ? "" : "none";
      ui.d1TimeWrap.style.display = appState.inputs.d1Mode === "time" ? "" : "none";
      ui.lineLengthOverrideM.disabled = !appState.inputs.useManualLineLength;
      ui.lineLengthOverrideNm.disabled = !appState.inputs.useManualLineLength;
      ui.kWave.disabled = !appState.advanced.waveEnabled;
      ui.waveHeightM.disabled = !appState.advanced.waveEnabled;
      ui.waveDirectionFromDeg.disabled = !appState.advanced.waveEnabled;
    }

    function updateSummary() {
      const l = derivedState.line;
      const d1 = derivedState.d1;
      const r3 = derivedState.rule3;
      const upwind = derivedState.speeds.upwindKn;
      const correctedRcBearing = appState.inputs.rule3Enabled ? r3.bearingRcCorrectedFromCenter : r3.bearingCbRaw;
      const fleetTimeFactor = LEVEL_MULTIPLIER[appState.inputs.fleetLevel] || 1;
      const mark1TimeMultiplier = Number(appState.advanced.mark1TimeMultiplier || 1);
      const waveTimeFactor = Number(l.waveTimeFactor || 1);
      const combinedTimeFactor = fleetTimeFactor * mark1TimeMultiplier * waveTimeFactor;
      const estimatedTimeToM1RawMin = upwind > 0 ? (d1.d1Nm / upwind) * 60 : null;
      const estimatedTimeToM1Min = estimatedTimeToM1RawMin == null ? null : estimatedTimeToM1RawMin * combinedTimeFactor;

      const items = [
        ["RC → Pin Line Bearing", `${fmt(l.headingDeg,1)}°`],
        ["Upwind Heading", `${fmt(l.upwindHeadingDeg,1)}°`],
        ["Current Line Correction", `${fmt(l.deltaCurrentDeg,2)}°`],
        ["Wave Line Correction", `${fmt(l.deltaWaveDeg,2)}°`],
        ["Total Line Correction", `${fmt(l.deltaLineDeg,2)}°`],
        ["Line Length", `${fmt(l.lengthM,1)} m (${fmt(l.lengthNm,3)} NM)`],
        ["Auto Line Length", `${fmt(l.autoLengthM,1)} m (${fmt(l.autoLengthNm,3)} NM)`],
        ["Mark 1 Distance (D1)", `${fmt(d1.d1M,1)} m (${fmt(d1.d1Nm,3)} NM)`],
        ["Estimated Time to Mark 1", `${fmt(estimatedTimeToM1Min,1)} min (x${fmt(combinedTimeFactor,2)})`],
        ["Estimated Upwind Speed", `${fmt(upwind,2)} kn`],
        ["Wave Time Factor", l.waveEnabled ? `x${fmt(waveTimeFactor,2)} (${fmt(l.waveHeightM,1)} m @ ${fmtDeg(l.waveDirectionFromDeg)}° from)` : "x1.00 (waves off)"],
        ["Mark 1 Bearing from Center", `${fmtDeg(r3.bearingCenter)}°`],
        ["Mark 1 Bearing from RC (raw)", `${fmtDeg(r3.bearingCbRaw)}°`],
        ["Mark 1 Bearing from RC (corrected)", `${fmtDeg(correctedRcBearing)}° ${appState.inputs.rule3Enabled ? "" : "(Rule 3 off)"}`],
        ["Rule 3 Correction Applied", `${fmt(r3.correctionAppliedDeg,2)}°`]
      ];

      ui.summaryGrid.innerHTML = items.map(([k, v]) => `<div class="metric"><span class="k">${k}</span><div class="v">${v}</div></div>`).join("");
      ui.rule3Summary.textContent = `Rule 3: parallax ${fmt(r3.parallaxDeg,2)}° · side ${r3.side} · applied ${fmt(r3.correctionAppliedDeg,2)}° · Δ(raw RC vs center) ${fmt(r3.deltaCenterVsCbRawDeg,2)}° · center-equivalent check ${fmt(r3.deltaCenterVsCbCorrectedDeg,2)}°`;
    }

    function updatePointsTable() {
      const r3 = derivedState.rule3;
      const tbody = ui.pointsTable.querySelector("tbody");
      tbody.innerHTML = derivedState.pointsRows.map((row) => {
        const rcRawBearing = fmtDeg(row.bearingCb);
        let rcCorrectedBearing = "—";
        if (row.name === "RC") rcCorrectedBearing = "0";
        else if (row.name === "Pin") rcCorrectedBearing = fmtDeg(row.bearingCb);
        else if (row.name === "M1") rcCorrectedBearing = `${fmtDeg(appState.inputs.rule3Enabled ? r3.bearingRcCorrectedFromCenter : r3.bearingCbRaw)}${appState.inputs.rule3Enabled ? " (R3)" : " (off)"}`;
        return `
          <tr>
            <td>${row.name}</td>
            <td>${fmtDeg(row.bearingCenter)}</td>
            <td>${rcRawBearing}</td>
            <td>${rcCorrectedBearing}</td>
            <td>${fmtDeg(row.bearingPin)}</td>
            <td>${fmt(row.distNm,3)}</td>
          </tr>`;
      }).join("");
    }

    function updateDiagramStats() {
      const l = derivedState.line;
      const idealHeading = mod360(Number(appState.inputs.twd) + 90);
      ui.diagramStats.innerHTML = `
        <div class="diagram-stats-col">
          <div class="diagram-stats-line"><strong>Compensated Line (RC→Pin):</strong> ${fmt(l.headingDeg,1)}°</div>
          <div class="diagram-stats-line">Wind-only Line (TWD+90): ${fmt(idealHeading,1)}°</div>
          <div class="diagram-stats-line">Line Length: ${fmt(l.lengthM,1)} m (${fmt(l.lengthNm,3)} NM)</div>
          <div class="diagram-stats-line">Current Correction: ${fmt(l.deltaCurrentDeg,2)}° · Wave Correction: ${fmt(l.deltaWaveDeg,2)}°${l.waveEnabled ? "" : " (off)"}</div>
        </div>
        <div class="diagram-stats-col">
          <div class="diagram-stats-line"><strong>Wind (TWD):</strong> ${fmtDeg(appState.inputs.twd)}° from</div>
          <div class="diagram-stats-line">Current: ${fmtDeg(appState.inputs.currentSet)}° · ${fmt(appState.inputs.currentDrift,1)} kn</div>
          <div class="diagram-stats-line">Waves: ${l.waveEnabled ? `${fmt(l.waveHeightM,1)} m from ${fmtDeg(l.waveDirectionFromDeg)}° · time factor x${fmt(l.waveTimeFactor,2)}` : "off"}</div>
          <div class="diagram-stats-line">Upwind Heading: ${fmt(l.upwindHeadingDeg,1)}°</div>
          <div class="diagram-stats-line">Fleet: ${appState.inputs.boatClass} · ${Math.round(appState.inputs.participants)} boats · ${appState.inputs.fleetLevel}</div>
        </div>
      `;
    }

    function svgLine(x1, y1, x2, y2, attrs = "") {
      return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" ${attrs}></line>`;
    }
    function svgCircle(cx, cy, r, attrs = "") { return `<circle cx="${cx}" cy="${cy}" r="${r}" ${attrs}></circle>`; }
    function svgText(x, y, text, attrs = "") { return `<text x="${x}" y="${y}" ${attrs}>${text}</text>`; }

    function arrowEnd(x, y, len, bearingDeg) {
      const r = degToRad(bearingDeg);
      return { x: x + Math.sin(r) * len, y: y - Math.cos(r) * len };
    }

    function arrowSvg(x, y, len, bearingDeg, color, label) {
      const end = arrowEnd(x, y, len, bearingDeg);
      const head = 10;
      const left = arrowEnd(end.x, end.y, head, bearingDeg + 150);
      const right = arrowEnd(end.x, end.y, head, bearingDeg - 150);
      return `
        ${svgLine(x, y, end.x, end.y, `stroke="${color}" stroke-width="3"`)}
        ${svgLine(end.x, end.y, left.x, left.y, `stroke="${color}" stroke-width="3"`)}
        ${svgLine(end.x, end.y, right.x, right.y, `stroke="${color}" stroke-width="3"`)}
        ${svgText(end.x + 10, end.y - 6, label, 'fill="#10212f" font-size="14" font-weight="600"')}
      `;
    }

    function renderDiagram() {
      const svg = ui.diagram;
      const l = derivedState.line;
      const center = { x: 500, y: 330 };
      const halfLen = 190;
      const idealHeading = mod360(Number(appState.inputs.twd) + 90);
      const windFlowHeading = mod360(Number(appState.inputs.twd) + 180); // arrow shows where the wind goes
      const currentHeading = mod360(Number(appState.inputs.currentSet));

      const visualPoint = (origin, len, bearingDeg) => ({
        x: origin.x + Math.sin(degToRad(bearingDeg)) * len,
        y: origin.y - Math.cos(degToRad(bearingDeg)) * len
      });

      const idealCb = visualPoint(center, halfLen, mod360(idealHeading + 180));
      const idealPin = visualPoint(center, halfLen, idealHeading);
      const cb = visualPoint(center, halfLen, mod360(l.headingDeg + 180));
      const pin = visualPoint(center, halfLen, l.headingDeg);

      const windBase = { x: 88, y: 108 };
      const currentBase = { x: 88, y: 222 };
      const northBase = { x: 886, y: 118 };

      const html = `
        <defs>
          <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
            <feDropShadow dx="0" dy="1" stdDeviation="1.4" flood-color="#9fb3c2" flood-opacity="0.4"/>
          </filter>
        </defs>
        <rect x="0" y="0" width="1000" height="620" fill="transparent"></rect>
        <g opacity="0.28">
          ${Array.from({ length: 10 }).map((_, i) => svgLine(60 + i * 95, 40, 60 + i * 95, 580, 'stroke="#d8e3eb" stroke-width="1"')).join('')}
          ${Array.from({ length: 6 }).map((_, i) => svgLine(40, 70 + i * 90, 960, 70 + i * 90, 'stroke="#d8e3eb" stroke-width="1"')).join('')}
        </g>

        <g>
          ${arrowSvg(windBase.x, windBase.y, 64, windFlowHeading, '#111827', `TWD ${fmtDeg(appState.inputs.twd)}°`)}
          ${arrowSvg(currentBase.x, currentBase.y, 56, currentHeading, '#1d4ed8', `Current ${fmtDeg(currentHeading)}° · ${fmt(appState.inputs.currentDrift,1)} kn`)}
          ${arrowSvg(northBase.x, northBase.y, 56, 0, '#334155', 'North 000°')}
        </g>

        <g>
          ${svgLine(70, 258, 930, 258, 'stroke="#e5edf4" stroke-width="1"')}
          ${svgText(74, 250, 'START LINE SCHEMATIC (not to chart scale)', 'fill="#64748b" font-size="11" font-weight="600"')}

          ${svgLine(idealCb.x, idealCb.y, idealPin.x, idealPin.y, 'stroke="#94a3b8" stroke-width="4" stroke-dasharray="10 8" stroke-linecap="round"')}
          ${svgLine(cb.x, cb.y, pin.x, pin.y, 'stroke="#005f73" stroke-width="5" stroke-linecap="round" filter="url(#shadow)"')}
          ${svgLine(center.x, center.y, center.x + Math.sin(degToRad(l.upwindHeadingDeg)) * 74, center.y - Math.cos(degToRad(l.upwindHeadingDeg)) * 74, 'stroke="#0f766e" stroke-width="2.5" opacity="0.70"')}

          ${svgCircle(cb.x, cb.y, 9, 'fill="#7c2d12" stroke="#fff" stroke-width="2"')}
          ${svgCircle(pin.x, pin.y, 9, 'fill="#1d4ed8" stroke="#fff" stroke-width="2"')}
          ${svgCircle(center.x, center.y, 4, 'fill="#334155"')}

          ${svgText(cb.x - 14, cb.y - 16, 'RC', 'fill="#7c2d12" font-size="14" font-weight="700"')}
          ${svgText(pin.x + 12, pin.y - 16, 'Pin', 'fill="#1d4ed8" font-size="14" font-weight="700"')}
          ${svgText(center.x + 8, center.y - 8, 'Center', 'fill="#334155" font-size="12" font-weight="600"')}

          ${svgText((idealCb.x + idealPin.x) / 2 - 96, (idealCb.y + idealPin.y) / 2 + 18, `Wind-only line ${fmt(idealHeading,1)}°`, 'fill="#64748b" font-size="12" font-weight="700"')}
          ${svgText((cb.x + pin.x) / 2 - 92, (cb.y + pin.y) / 2 - 14, `Compensated line ${fmt(l.headingDeg,1)}°`, 'fill="#005f73" font-size="13" font-weight="700"')}

        </g>
      `;

      svg.innerHTML = html;
    }

    function syncFormFromState() {
      const i = appState.inputs;
      const a = appState.advanced;
      ui.twd.value = i.twd;
      ui.tws.value = i.tws;
      ui.currentSet.value = i.currentSet;
      ui.currentDrift.value = i.currentDrift;
      ui.boatClass.value = i.boatClass;
      ui.participants.value = i.participants;
      ui.fleetLevel.value = i.fleetLevel;
      ui.d1Mode.value = i.d1Mode;
      ui.d1Nm.value = i.d1Nm;
      ui.targetTimeUpwindMin.value = i.targetTimeUpwindMin;
      ui.useManualLineLength.checked = i.useManualLineLength;
      ui.lineLengthOverrideM.value = Number(i.lineLengthOverrideM).toFixed(1);
      ui.lineLengthOverrideNm.value = Number(i.lineLengthOverrideNm).toFixed(3);
      ui.rule3Enabled.checked = i.rule3Enabled;

      ui.basePaddingM.value = a.basePaddingM;
      ui.kCurrent.value = a.kCurrent;
      ui.kWave.value = a.kWave;
      ui.lineClampMinM.value = a.lineClampMinM;
      ui.lineClampMaxM.value = a.lineClampMaxM;
      ui.deltaLineClampDeg.value = a.deltaLineClampDeg;
      ui.mark1TimeMultiplier.value = Number(a.mark1TimeMultiplier).toFixed(2);
      ui.waveEnabled.checked = !!a.waveEnabled;
      ui.waveHeightM.value = Number(a.waveHeightM).toFixed(1);
      ui.waveDirectionFromDeg.value = Math.round(mod360(a.waveDirectionFromDeg));
    }

    function recomputeAndRender(statusMsg) {
      sanitizeState();
      recomputeDerived();
      syncFormFromState();
      updateConditionalUI();
      updateSummary();
      updatePointsTable();
      updateDiagramStats();
      renderDiagram();
      if (statusMsg) setStatus(statusMsg);
    }

    function bindInputs() {
      [
        ["twd", "twd"], ["tws", "tws"], ["currentSet", "currentSet"], ["currentDrift", "currentDrift"],
        ["participants", "participants"], ["d1Nm", "d1Nm"], ["targetTimeUpwindMin", "targetTimeUpwindMin"],
        ["lineLengthOverrideM", "lineLengthOverrideM"]
      ].forEach(([id, key]) => {
        ui[id].addEventListener("input", () => {
          appState.inputs[key] = Number(ui[id].value);
          if (id === "lineLengthOverrideM") appState.inputs.lineLengthOverrideNm = Number(ui[id].value) * M_TO_NM;
          recomputeAndRender();
        });
      });

      ui.lineLengthOverrideNm.addEventListener("input", () => {
        appState.inputs.lineLengthOverrideNm = Number(ui.lineLengthOverrideNm.value);
        appState.inputs.lineLengthOverrideM = appState.inputs.lineLengthOverrideNm * NM_TO_M;
        recomputeAndRender();
      });

      [["boatClass", "boatClass"], ["fleetLevel", "fleetLevel"], ["d1Mode", "d1Mode"]]
        .forEach(([id, key]) => ui[id].addEventListener("change", () => {
          appState.inputs[key] = ui[id].value;
          recomputeAndRender();
        }));

      [["useManualLineLength", "useManualLineLength"], ["rule3Enabled", "rule3Enabled"]]
        .forEach(([id, key]) => ui[id].addEventListener("change", () => {
          appState.inputs[key] = ui[id].checked;
          recomputeAndRender();
        }));

      ui.waveEnabled.addEventListener("change", () => {
        appState.advanced.waveEnabled = ui.waveEnabled.checked;
        recomputeAndRender();
      });

      [["basePaddingM", "basePaddingM"], ["kCurrent", "kCurrent"], ["kWave", "kWave"], ["lineClampMinM", "lineClampMinM"], ["lineClampMaxM", "lineClampMaxM"], ["deltaLineClampDeg", "deltaLineClampDeg"], ["mark1TimeMultiplier", "mark1TimeMultiplier"], ["waveHeightM", "waveHeightM"], ["waveDirectionFromDeg", "waveDirectionFromDeg"]]
        .forEach(([id, key]) => ui[id].addEventListener("input", () => {
          appState.advanced[key] = Number(ui[id].value);
          recomputeAndRender();
        }));

      ui.recomputeAll.addEventListener("click", () => {
        recomputeAndRender("Recompute completed.");
      });

      ui.resetDefaults.addEventListener("click", () => {
        Object.assign(appState, JSON.parse(JSON.stringify(DEFAULT_STATE)));
        recomputeAndRender("Full reset completed.");
      });
    }

    function cacheUI() {
      [
        "twd", "tws", "currentSet", "currentDrift", "boatClass", "participants", "fleetLevel", "d1Mode", "d1Nm", "targetTimeUpwindMin",
        "useManualLineLength", "lineLengthOverrideM", "lineLengthOverrideNm", "rule3Enabled",
        "basePaddingM", "kCurrent", "kWave", "lineClampMinM", "lineClampMaxM", "deltaLineClampDeg",
        "mark1TimeMultiplier", "waveEnabled", "waveHeightM", "waveDirectionFromDeg",
        "recomputeAll", "resetDefaults", "appStatus", "d1NmWrap", "d1TimeWrap",
        "summaryGrid", "rule3Summary", "pointsTable", "diagram", "diagramStats"
      ].forEach((id) => ui[id] = document.getElementById(id));
    }

    function init() {
      cacheUI();
      ui.boatClass.innerHTML = BOAT_CLASSES.map((c) => `<option value="${c}">${c}</option>`).join("");
      syncFormFromState();
      bindInputs();
      recomputeAndRender();
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>
